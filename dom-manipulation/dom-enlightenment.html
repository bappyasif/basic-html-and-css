<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOM Enlightenment Code Along</title>
    <link id="linkElement" href="http://yui.yahooapis.com/3.3.0/build/cssreset/reset-min.css" rel="stylesheet"
        type="text/css">
</head>

<!-- inline attribure event handler pattern -->

<body onclick="console.log('fire/trigger attribure event handler')">
    <!-- The insertAdjacentHTML() method which only works on Element nodes -->
    <!-- Using this method its possible to insert nodes before the beginning tag, after the beginning tag, before the end tag, and after the end tag -->
    <!-- The insertAdjacentHTML options "beforebegin" and "afterend" will only work if the node is in the DOM tree and has a parent element -->
    <!-- innerText is aware of style and will not return the text of hidden elements, whereas textContent will -->
    <i id="elm">how</i>
    <script>
        var elm = document.getElementById('elm');

        elm.insertAdjacentHTML('beforebegin', '<span>Hey-</span>');
        elm.insertAdjacentHTML('afterbegin', '<span>dude-</span>');
        elm.insertAdjacentHTML('beforeend', '<span>-are</span>');
        elm.insertAdjacentHTML('afterend', '<span>-you?</span>');

        console.log(document.body.innerHTML);
    </script>

    <!--  (innerHTML, outerHTML, textContent) that we use to create and add nodes to the DOM can also be used to extract parts of the DOM (or really the entire DOM) as a JavaScript string -->
    <!-- The textContent, innerText, outerText property when being read will return all of the text nodes contained within the selected node -->
    <div id="A"><i>Hi</i></div>
    <div id="B">Dude<strong> !</strong></div>
    <script>
        console.log(document.getElementById('A').innerHTML); //logs '<i>Hi</i>'

        console.log(document.getElementById('A').outerHTML); //logs <div id="A">Hi</div>

        //notice that all text is returned even if its in child element nodes (i.e. <strong> !</strong>) 
        console.log(document.getElementById('B').textContent); //logs 'Dude !'

        //NON standard extensions below i.e. innerText & outerText

        console.log(document.getElementById('B').innerText); //logs 'Dude !'

        console.log(document.getElementById('B').outerText); //logs 'Dude !'​​
    </script>

    <!-- appendChild() and insertBefore() Node methods allow us to insert JavaScript node objects into the DOM tree -->
    <!-- appendChild() method will append a node(s) to the end of the child node(s) of the node the method is called on -->
    <!-- When it becomes necessary to control the location of insertion beyond appending nodes to the end of a child list of nodes we can use insertBefore() -->
    <!-- insertBefore() requires two parameters, the node to be inserted and the reference node in the document you would like the node inserted before -->
    <!-- If you do not pass the insertBefore() method a second parameter then it functions just like appendChild() -->
    <p>Hi</p>
    <script>
        //create a blink element node and text node
        var elementNode = document.createElement('strong');
        var textNode = document.createTextNode(' Dude');

        //append these nodes to the DOM
        document.querySelector('p').appendChild(elementNode);
        document.querySelector('strong').appendChild(textNode);

        //log's <p>Hi<strong> Dude</strong></p>
        console.log(document.body.innerHTML);
    </script>
    <ul>
        <li>2</li>
        <li>3</li>
    </ul>
    <script>
        //create a text node and li element node and append the text to the li
        var text1 = document.createTextNode('1');
        var li = document.createElement('li');
        li.appendChild(text1);

        //select the ul in the document
        var ul = document.querySelector('ul');

        /* 
        add the li element we created above to the DOM, notice I call on <ul> and pass reference to <li>2</li> using ul.firstChild 
        */
        ul.insertBefore(li, ul.firstChild);

        console.log(document.body.innerHTML);
    </script>

    <!-- Replacing an element or text node is not unlike removing one -->
    <!-- Depending upon what you are removing or replacing simply providing the innerHTML, outerHTML, and textContent properties with an empty string might be easier and faster -->
    <!-- Both replaceChild() and removeChild() return the replaced or remove node. Basically its not gone just because you replace it or remove -->
    <div id="A1">Hi</div>
    <div id="B1">Dude</div>
    <script>
        //replace element node
        var divA = document.getElementById('A1');
        var newSpan = document.createElement('span');
        newSpan.textContent = 'Howdy';
        divA.parentNode.replaceChild(newSpan, divA);

        //replace text node
        var divB = document.getElementById('B1').firstChild;
        var newText = document.createTextNode('buddy');
        divB.parentNode.replaceChild(newText, divB);

        //log the new DOM updates, 
        console.log(document.body.innerHTML);
    </script>

    <!-- Using the cloneNode() method its possible to duplicate a single node or a node and all its children nodes -->
    <!-- To clone a node and all of its children nodes you pass the cloneNode() method a parameter of true -->
    <!-- When cloning an Element node all attributes and values are also cloned. In fact, only attributes are copied! Everything else you can add (e.g. event handlers) to a DOM node is lost when cloning -->
    <ul id="for-clone">
        <li>Hi</li>
        <li>there</li>
    </ul>
    <script>
        var cloneUL = document.querySelector('#for-clone').cloneNode();

        console.log(cloneUL.constructor); //logs HTMLUListElement()
        console.log(cloneUL.innerHTML); //logs (an empty string) as only the ul was cloned
    </script>
    <ul id="for-clone-all-nodes">
        <li>Hi</li>
        <li>there</li>
    </ul>
    <script>
        var cloneUL = document.querySelector('#for-clone-all-nodes').cloneNode(true);

        console.log(cloneUL.constructor); //logs HTMLUListElement()
        console.log(cloneUL.innerHTML); //logs <li>Hi</li><li>th
    </script>

    <!-- A collection can either be live or static. Meaning that the nodes contained in the collection are either literally part of the live document or a snapshot of the live document -->
    <!-- By default nodes are sorted inside of the collection by tree order. Meaning the order matches the liner path from tree trunk to branches -->
    <!-- The collections have a length property that reflects the number of elements in the list -->
    <!-- Using the childNodes property produces an array like list (i.e. NodeList) of the immediate child nodes -->
    <script>

        var ulElementChildNodes = document.querySelector('ul').childNodes;

        console.log(ulElementChildNodes); //logs an array like list of all nodes inside of the ul

        /*Call forEach as if its a method of NodeLists so we can loop over the NodeList. Done because NodeLists are array like, but do not directly inherit from Array*/
        Array.prototype.forEach.call(ulElementChildNodes, function (item) {
            console.log(item); //logs each item in the array
        });

    </script>

    <!-- Node lists and html collections are array like but not a true JavaScript array which inherits array methods -->
    <!-- Converting a node list and html collection list to a true JavaScript array can provide a good deal of advantages -->
    <!-- For one it gives us the ability to create a snapshot of the list that is not tied to the live DOM considering that NodeList and HTMLCollection are live lists -->
    <!-- Secondly, converting a list to a JavaScript array gives access to the methods provided by the Array object -->
    <!-- To convert an array like list to a true JavaScript array pass the array-like list to call() or apply(), in which the call() or apply() is calling a method that returns an un-altered true JavaScript array -->
    <!-- Array.from to look forward to which converts a single argument that is an array-like object or list -->
    <a href="#"></a>

    <script>

        console.log(Array.isArray(Array.prototype.slice.call(document.links))); //returns true
        console.log(Array.isArray(Array.prototype.slice.call(document.querySelectorAll('a')))); //returns true

    </script>

    <!-- From a node reference its possible to get a different node reference by traversing the DOM using the following properties: parentNode, firstChild, lastChild, nextSibling, previousSibling -->
    <ul id="traversing-dom">
        <!-- comment -->
        <li id="AA"></li>
        <li id="BB"></li>
        <!-- comment -->
    </ul>

    <script>
        //cache selection of the ul
        var ul = document.querySelector('#traversing-dom');

        //What is the parentNode of the ul?
        console.log(ul.parentNode.nodeName); //logs body

        //What is the first child of the ul?
        console.log(ul.firstChild.nodeName); //logs comment

        //What is the last child of the ul?
        console.log(ul.lastChild.nodeName); //logs text not comment, because there is a line break

        //What is the nextSibling of the first li?
        console.log(ul.querySelector('#AA').nextSibling.nodeName); //logs text

        //What is the previousSibling of the last li?
        console.log(ul.querySelector('#BB').previousSibling.nodeName); //logs text
    </script>
    <!-- Using the following properties we can traverse the DOM ignoring text and comment nodes: firstElementChild, lastElementChild, nextElementChild, previousElementChild, children -->
    <script>
        //cache selection of the ul
        var ul = document.querySelector('#traversing-dom');

        //What is the first child of the ul?
        console.log(ul.firstElementChild.nodeName); //logs li

        //What is the last child of the ul?
        console.log(ul.lastElementChild.nodeName); //logs li

        //What is the nextSibling of the first li?
        console.log(ul.querySelector('#AA').nextElementSibling.nodeName); //logs li

        //What is the previousSibling of the last li?
        console.log(ul.querySelector('#BB').previousElementSibling.nodeName); //logs li

        //What are the element only child nodes of the ul? 
        console.log(ul.children); //HTMLCollection, all child nodes including text nodes

    </script>

    <!-- Its possible to know if a node is contained inside of another node by using the contains() Node method -->
    <!-- If you need more robust information about the position of a node in the DOM tree in regards to the nodes around it you can use the compareDocumentPosition() Node method -->
    <!-- contains() will return true if the node selected and node passed in are identical -->
    <script>
        // is <body> inside <html lang="en"> ?
        var inside = document.querySelector('html').contains(document.querySelector('body'));

        console.log(inside); //logs true
    </script>

    <!-- 
        two nodes are equal if and only if the following conditions are satisfied: 
            > The two nodes are of the same type
            > The following string attributes are equal: nodeName, localName, namespaceURI, prefix, nodeValue. That is: they are both null, or they have the same length and are character for character identical
            > The attributes NamedNodeMaps are equal. That is: they are both null, or they have the same length and for each node that exists in one map there is a node that exists in the other map and is equal, although not necessarily at the same index
            > The childNodes NodeLists are equal. That is: they are both null, or they have the same length and contain equal nodes at the same index. Note that normalization can affect equality; to avoid this, nodes should be normalized before being compared
    -->
    <!-- Calling the .isEqualNode() method on a node in the DOM will ask if that node is equal to the node that you pass it as a parameter -->
    <!-- If you don't care about two nodes being exactly equal but instead want to know if two node references refer to the same node you can simply check it using the === opertor (i.e. document.body === document.body). This will tell us if they are identical but no equal -->
    <input type="text">
    <input type="text">

    <textarea>foo</textarea>
    <textarea>bar</textarea>

    <script>

        //logs true, because they are exactly idential
        var input = document.querySelectorAll('input');
        console.log(input[0].isEqualNode(input[1]));

        //logs false, because the child text node is not the same
        var textarea = document.querySelectorAll('textarea');
        console.log(textarea[0].isEqualNode(textarea[1]));

    </script>

    <!-- To get accurate information pertaining to the available properties and methods on an HTMLDocument node its best to ignore the specification and to ask the browser what is available -->
    <script>

        //document own properties
        console.log(Object.keys(document).sort());

        //document own properties & inherited properties
        var documentPropertiesIncludeInherited = [];
        for (var p in document) {
            documentPropertiesIncludeInherited.push(p);
        }
        console.log(documentPropertiesIncludeInherited.sort());

        //documment inherited properties only
        var documentPropertiesOnlyInherited = [];
        for (var p in document) {
            if (
                !document.hasOwnProperty(p)) {
                documentPropertiesOnlyInherited.push(p);
            }
        }
        console.log(documentPropertiesOnlyInherited.sort());

    </script>

    <!-- document object provides access to some general information about the HTML document/DOM being loaded -->
    <script>

        var d = document;
        console.log('title = ' + d.title);
        console.log('url = ' + d.URL);
        console.log('referrer = ' + d.referrer);
        console.log('lastModified = ' + d.lastModified);

        //logs either BackCompat (Quirks Mode) or CSS1Compat (Strict Mode)
        console.log('compatibility mode = ' + d.compatMode);

    </script>

    <!-- Using the document.activeElement we can quickly get a reference to the node in the document that is focused/active -->
    <textarea id="textarea"></textarea>
    <script>

        //set focus to <textarea>
        document.querySelector('#textarea').focus();

        //get reference to element that is focused/active in the document
        console.log(document.activeElement); //logs <textarea>

        //If you keep focus on the window/tab that has the document loaded its true. If not it's false.
        setTimeout(function () { console.log(document.hasFocus()) }, 5000);

        // The head object in a web browser is the window object and defaultView will point to this object in a JavaScript browser enviroment
        // If you are dealing with a DOM that is headless or an JavaScript enviroment that is not running in a web browser (i.e. node.js) this property can get you access to the head object scope
        console.log(document.defaultView) //reference, head JS object. 

    </script>

    <!-- ownerDocument property when called on a node returns a reference to the Document the node is contained within -->
    <!-- If ownerDocument is called on the Document node the value returned is null -->
    <iframe src="http://someFileServedFromServerOnSameDomain.html"></iframe>

    <script>

        //get the window.document that the <body> is contained within
        console.log(document.body.ownerElement, document.ownerDocument);

        //get the window.document the <body> inside of the iframe is contained within
        console.log(window.frames[0].document.body.ownerElement);

        console.log(document.querySelector('a').tagName); //logs A

        //the nodeName property returns the same value
        console.log(document.querySelector('a').nodeName); //logs A

    </script>

    <!-- Using the attributes property (inherited by element nodes from Node) we can get a collection of the Attr nodes that an element currently has defined -->
    <!-- The array returned from accessing the attributes property should be consider live. Meaning that its contents can be changed at anytime -->
    <a id="attr" href='#' title="title" data-foo="dataFoo" class="yes" style="margin:0;" foo="boo" goo></a>
    <div id="div-class" class="big brown bear toggle"></div>
    <div class="visible"></div>
    <script>

        var atts = document.querySelector('#attr').attributes;

        for (var i = 0; i < atts.length; i++) {
            console.log(atts[i].nodeName + '=' + atts[i].nodeValue);
        }

        // The most consistent way to get, set, or remove an elements attribute value is to use the getAttribute(), setAttribute(), and removeAttribute() method
        // Use removeAttribute() instead of setting the attribute value to null or '' using setAttribute()
        atts = document.querySelector('#attr')

        //remove attributes
        atts.removeAttribute('href');
        atts.removeAttribute('title');
        atts.removeAttribute('style');
        atts.removeAttribute('data-foo');
        atts.removeAttribute('class');
        atts.removeAttribute('foo'); //custom attribute
        atts.removeAttribute('hidden'); //boolean attribute

        //set (really re-set) attributes
        atts.setAttribute('href', '#');
        atts.setAttribute('title', 'title');
        atts.setAttribute('style', 'margin:0;');
        atts.setAttribute('data-foo', 'dataFoo');
        atts.setAttribute('class', 'yes');
        atts.setAttribute('foo', 'boo');
        atts.setAttribute('hidden', 'hidden'); //boolean attribute requires sending the attribute as the value too

        //get attributes
        console.log(atts.getAttribute('href'));
        console.log(atts.getAttribute('title'));
        console.log(atts.getAttribute('style'));
        console.log(atts.getAttribute('data-foo'));
        console.log(atts.getAttribute('class'));
        console.log(atts.getAttribute('foo'));
        console.log(atts.getAttribute('hidden'));

        // best way to determine (i.e. boolean) if an element has an attribute is to use the hasAttribute()  method
        console.log(
            atts.hasAttribute('href'),
            atts.hasAttribute('title'),
            atts.hasAttribute('style'),
            atts.hasAttribute('data-foo'),
            atts.hasAttribute('class'),
            atts.hasAttribute('goo') //Notice this is true regardless if a value is defined 
        )

        console.log(atts.hasAttribute('checked')); //logs false, preferably used with checkboxes

        // classList is read-only but can be modified using the add(), remove(), contains(), and toggle() methods
        var elm = document.querySelector('#div-class');

        console.log(elm.classList); //big brown bear {0="big", 1="brown", 2="bear", length=3, ...}
        console.log(elm.className); //logs 'big brown bear'

        elm.classList.add('cat');
        elm.classList.remove('dog');
        console.log(elm.className); //'cat'

        // Using the classList.toggle() method we can toggle a sub-value of the class attribute
        // elem = document.querySelector('.visible')
        elm.classList.toggle('visible');
        elm.classList.toggle('grow');
        console.log(elm.className); //'grow'

        // Using the classList.contains() method its possible to determine (boolean) if a class attribute value contains a specific sub-value
        console.log(elm.classList.contains('brown')); //logs true

        // The dataset property of a element node provides an object containing all of the attributes of an element that starts with data-*
        // dataset contains camel case versions of data attributes. Meaning data-foo-foo will be listed as the property fooFoo in the dataset DOMStringMap object
        // Removing a data-* attribute from the DOM is as simple using the delete operator on a property of the datset (e.g. delete dataset.fooFoo)
        elm = document.querySelector('#attr')
        //get
        console.log(elm.dataset.fooFoo); //logs 'foo'
        console.log(elm.dataset.barBar); //logs 'bar'

        //set
        elm.dataset.gooGoo = 'goo';
        console.log(elm.dataset); //logs DOMStringMap {fooFoo="foo", barBar="bar", gooGoo="goo"}

        //what the element looks like in the DOM 
        console.log(elm);

        // getElementsByTagName() and getElementsByClassName() are considered live are will always reflect the state of the document even if the document is updated after the list is created/selected
        // querySelectorAll() method does not return a live list of elements. Meaning that the list created from querySelectorAll() is a snap shot of the document at the time it was created and is not reflective of the document as it changes. The list is static not live
        // Passing either querySelectorAll() or getElementsByTagName() the string '*', which generally means all, will return a list of all elements in the document
        // Using the children property from an element node we can get a list (aka HTMLCollection) of all the immediate children nodes that are element nodes
        // using children only gives us the immediate element nodes excluding any nodes (e.g. text nodes) that are not elements. If the element has no children then children will return an empty array-like-list

        // You should be aware that there are some legacy, pre-configured arrays-like-lists, containing element nodes from an HTML document
        /**
        document.all - all elements in HTML document
        document.forms - all <form> elements in HTML document
        document.images - all <img> elements in HTML document
        document.links - all <a> elements in HTML document
        document.scripts - all <script> elements in HTML document
        document.styleSheets - all <link> or <style> objects in HTML document
         */
    </script>

    <!-- Using the properties offsetTop and offsetLeft we can get the offset pixel value of an element node from the offsetParent -->
    <!-- These element node properties give us the distance in pixels from an elements outside top and left border to the inside top and left border of the offsetParent -->
    <!-- The value of the offsetParent is determined by searching the nearest ancestor elements for an element that has a CSS position value not equal to static -->
    <!-- If none are found then the <body> element or what some refer to as the "document" (as opposed to the browser viewport) is the offsetParent value -->
    <style>
        body {
            margin: 0;
        }

        #blue {
            height: 100px;
            width: 100px;
            background-color: blue;
            border: 10px solid gray;
            padding: 25px;
            margin: 25px;
            position: absolute;
            /* when relative padding and margin would be considered offset measurements */
        }

        #red {
            height: 50px;
            width: 50px;
            background-color: red;
            border: 10px solid gray;
        }
    </style>
    <div id="blue">
        <div id="red"></div>
    </div>

    <script>

        var div = document.querySelector('#red');

        console.log(div.offsetLeft); //logs 60
        console.log(div.offsetTop); //logs 60
        console.log(div.offsetParent); //logs <body>

    </script>

    <!-- Using the getBoundingClientRect() method we can get the position of an elements outside border edges as its painted in the browser viewport relative to the top and left edge of the viewport -->
    <style>
        #for-gbcr {
            height: 50px;
            width: 50px;
            background-color: red;
            border: 10px solid gray;
            margin: 100px;
        }
    </style>
    <div id="for-gbcr"></div>
    <script>

        var divEdges = document.querySelector('#for-gbcr').getBoundingClientRect();

        console.log(divEdges.top, divEdges.right, divEdges.bottom, divEdges.left, divEdges.height, divEdges.width); //logs '100 170 170 100'

        // The exact same size values can also be found using from the offsetHeight and offsetWidth properties
        divEdges = document.querySelector('#for-gbcr')
        console.log(divEdges.offsetHeight, divEdges.offsetWidth)

        // clientWidth and clientHeight properties return a total size of an element by adding together the content of the element and its padding excluding the border sizes
        console.log(divEdges.clientHeight, divEdges.clientWidth)

        // Using elementFromPoint() it's possible to get a reference to the topmost element in an html document at a specific point in the document
        console.log(document.elementFromPoint(50, 50));

    </script>

    <!-- scrollHeight and scrollWidth properties simply give you the height and width of the node being scrolled  -->
    <style>
        /* * {
            margin: 0;
            padding: 0;
        } */

        #for-scroll {
            height: 100px;
            width: 100px;
            overflow: auto;
        }

        #for-scroll p {
            height: 1000px;
            width: 1000px;
            background-color: red;
        }
    </style>
    <div id="for-scroll">
        <p></p>
    </div>
    <script>

        var div = document.querySelector('#for-scroll');

        console.log(div.scrollHeight, div.scrollWidth); //logs '1000 1000'

        // scrollTop and scrollLeft properties are read-write properties that return the pixels to the left or top that are not currently viewable in the scrollable viewport due to scrolling
        div.scrollTop = 750;
        div.scrollLeft = 750;

        console.log(div.scrollTop, div.scrollLeft);

        // By selecting a node contained inside a node that is scrollable we can tell the selected node to scroll into view using the scrollIntoView() method
        // If you want to scroll align to the bottom of the element pass a parameter of false to the scrollIntoView() method
        // document.querySelector('content').children[4].scrollIntoView(true);
        div.children[0].scrollIntoView(true);

    </script>

    <!-- Inline CSS styles are individually represented as a property (i.e. object property) of the style object avaliabe on element node objects -->
    <!-- This provides the interface for us to get, set, or remove individual CSS properties on an element by simply setting an objects property value -->
    <div id="for-inlineCss"></div>
    <div id="for-inlineCss02" style="background-color:green;border:1px solid purple;"></div>
    <div id="for-cssText"></div>

    <script>

        var divStyle = document.querySelector('#for-inlineCss').style;
        // Remember to include for any css property value that requires a unit of measure the appropriate unit  (e.g. style.width = '300px'; not style.width = '300';)

        //set
        divStyle.backgroundColor = 'red';
        divStyle.border = '1px solid black';
        divStyle.width = '100px';
        divStyle.height = '100px';

        //get
        console.log(divStyle.backgroundColor);
        console.log(divStyle.border);
        console.log(divStyle.width);
        console.log(divStyle.height);

        /*remove
        divStyle.backgroundColor = '';
        divStyle.border = '';
        divStyle.width = '';
        divStyle.height = '';
        */

        // style object is a CSSStyleDeclaration object and it provides not only access to inidividual CSS properties, but also the setPropertyValue(propertyName), getPropertyValue(propertyName,value), and removeProperty() methods used to manipulate individual CSS properties on a element node
        divStyle = document.querySelector('#for-inlineCss02').style;

        // set
        divStyle.setProperty('background-color', 'red');
        divStyle.setProperty('border', '1px solid black');
        divStyle.setProperty('width', '100px');
        divStyle.setProperty('height', '100px');

        //get
        console.log(divStyle.getPropertyValue('background-color'));
        console.log(divStyle.getPropertyValue('border', '1px solid black'));
        console.log(divStyle.getPropertyValue('width', '100px'));
        console.log(divStyle.getPropertyValue('height', '100px'));

        /*remove
        divStyle.removeProperty('background-color');
        divStyle.removeProperty('border');
        divStyle.removeProperty('width');
        divStyle.removeProperty('height');
        */

        // Its possible using the cssText property of the CSSStyleDeclaration object as well as the getAttribute() and setAttribute() method to get, set, and remove the entire (i.e. all inline CSS properties) value of the style attribute using a JavaScript string
        // If its not obvious you should note that replacing the style attribute value with a new string is the fastest way to make multiple changes to an elements style
        divStyle = document.querySelector('#for-cssText').style;
        //set using cssText
        divStyle.cssText = 'background-color:red;border:1px solid black;height:100px;width:100px;';
        //get using cssText
        console.log(divStyle.cssText);
        //remove
        divStyle.cssText = '';

        //exactly that same outcome using setAttribute() and getAttribute()

        //set using setAttribute
        div.setAttribute('style', 'background-color:red;border:1px solid black;height:100px;width:100px;');
        //get using getAttribute
        console.log(div.getAttribute('style'));
        //remove
        div.removeAttribute('style');

        //  To get an elements css from the cascade (i.e. cascading from inline style sheets, external style sheets, browser style sheets) as well as its inline styles you can use getComputedStyle()
        // Shorthand properties are not computed for the CSSStyleDeclaration object you will have to use non-shorthand property names for property access (e.g. marginTop not margin)
        divStyle = document.querySelector('#for-inlineCss02')
        //logs rgb(0, 128, 0) or green, this is an inline element style
        console.log(window.getComputedStyle(divStyle).backgroundColor);

        //logs 1px solid rgb(128, 0, 128) or 1px solid purple, this is an inline element style
        console.log(window.getComputedStyle(divStyle).border);

        //logs 100px, note this is not an inline element style
        console.log(window.getComputedStyle(divStyle).height);

        //logs 100px, note this is not an inline element style
        console.log(window.getComputedStyle(divStyle).width);

    </script>

    <!-- When a DOM is contstructed either by the browser or by programmatic means text nodes are created from white space as well as from text characters -->
    <!-- This of course means that carriage returns are considered text nodes -->
    <p id="p1"></p> //yes there is a carriage return text node before this comment, even this comment is a node
    <p id="p2"></p>
    <p id="p3">Go big Blue Blue></p>
    <p id="mult-textNodes">Hi, <strong>cody</strong> welcome!</p>
    <p id="split-text">Hey Yo!</p>

    <script>

        console.log(document.querySelector('#p1').nextSibling) //logs Text

        // The text value/data represented by a Text node can be extracted from the node by using the .data or nodeValue property
        console.log(document.querySelector('p').firstChild.data); //logs 'Hi,'
        console.log(document.querySelector('p').firstChild.nodeValue); //logs 'Hi,'

        // Maniputlating Text nodes with appendData(), deleteData(), insertData(), replaceData(), subStringData()
        // var pElementText = document.querySelector('#p2').firstChild;
        var pElementText = document.querySelector('#p3').firstChild;

        //add !
        pElementText.appendData('!');
        console.log(pElementText.data);

        //remove first 'Blue'
        pElementText.deleteData(7, 5);
        console.log(pElementText.data);

        //insert it back 'Blue'
        pElementText.insertData(7, 'Blue ');
        console.log(pElementText.data);

        //replace first 'Blue' with 'Bunny'
        pElementText.replaceData(7, 5, 'Bunny ');
        console.log(pElementText.data);

        //extract substring 'Blue Bunny'
        console.log(pElementText.substringData(7, 10));

        // Typically, immediate sibling Text nodes do not occur because DOM trees created by browsers intelligently combines text nodes, however two cases exist that make sibling text nodes possible
        pElement = document.querySelector('#mult-textNodes');

        console.log(pElement.childNodes.length); //logs 3

        console.log(pElement.firstChild.data); // is text node or 'Hi, '
        console.log(pElement.firstChild.nextSibling); // is Element node or <strong>
        // console.log(pElement.lastChild.data); ​// is text node or ' welcome!'

        // The next case occurs when we are programatically add Text nodes to an element we created in our code
        pElementNode = document.createElement('p');
        var textNodeHi = document.createTextNode('Hi ');
        var textNodeCody = document.createTextNode('Cody');

        pElementNode.appendChild(textNodeHi);
        pElementNode.appendChild(textNodeCody);

        document.querySelector('div').appendChild(pElementNode);

        console.log(document.querySelector('div p').childNodes.length); //logs 2​​​​​​​​​​​​​​​​​​

        console.log(document.body.textContent); //logs 'Dude yo

        // document.body.textContent = 'You don\'t rock!'
        console.log(document.querySelector('div').textContent); //logs 'You don't rock!'

        // You should be aware of the following differences between textContent & innerText
        // innerText is aware of CSS. So if you have hidden text innerText ignores this text, whereas textContent will not
        // Because innerText cares about CSS it will trigger a reflow, whereas textContent will not
        // innerText ignores the Text nodes contained in <script> and <style> elements
        // innerText, unlike textContent will normalize the text that is returned. Just think of textContent as returning exactly what is in the document with the markup removed. This will include white space, line breaks, and carriage returns
        // innerText is considered to be non-standard and browser specific while textContent is implemented from the DOM specifications
        // To eliminate sibling Text nodes that contain no Element nodes we can use normalize()
        // This will concatenate sibling text nodes in the DOM into a single Text node
        pElementNode.appendChild(textNodeHi);
        pElementNode.appendChild(textNodeCody);

        document.querySelector('div').appendChild(pElementNode);

        console.log(document.querySelector('p').childNodes.length); //logs 2

        document.querySelector('div').normalize(); //combine our sibling text nodes

        console.log(document.querySelector('p').childNodes.length); //logs 1

        // When splitText() is called on a Text node it will alter the text node its being called on (leaving the text up to the offset) and return a new Text node that contains the text split off from the orginal text based on the offset
        //returns a new text node, taken from the DOM
        console.log(document.querySelector('#split-text').firstChild.splitText(4).data); //logs Yo!

        //What remains in the DOM...
        console.log(document.querySelector('#split-text').firstChild.textContent); //logs Hey

    </script>

    <!-- The creation and use of a DocumentFragment node provides a light weight document DOM that is external to the live DOM tree -->
    <!-- Think of a DocumentFragment as an empty document template that acts just like the live DOM tree, but only lives in memory, and its child nodes can easily be manipulated in memory and then appended to the live DOM -->
    <!-- Using a documentFragment to create node structures in memory is extrememly efficent when it comes time to inject the documentFragment into live node structures -->
    <ul id="for-fragments"></ul>
    <script>
        var docFrag = document.createDocumentFragment();

        ["blue", "green", "red", "blue", "pink"].forEach(function (e) {
            var li = document.createElement("li");
            li.textContent = e;
            docFrag.appendChild(li);
        });

        console.log(docFrag.textContent); //logs bluegreenredbluepink

        // advantage to using a documentFragment over simply creating (via createElement()), difference are as follows:
        // A document fragment may contain any kind of node (except <body> or <html>) where as an element may not
        // The document fragment itself, is not added to the DOM when you append a fragment. The contents of the node are. As opposed to appending an element node in which the element itself is part of the appending
        // When a document fragment is appended to the DOM it transfers from the document fragment to the place its appended. Its no longer in memory in the place you created it. This is not true for element nodes that are temperately used to contained nodes briefly and then are moved to the live DOM
        // Document fragments passed as arguments to inserting node methods will insert the entire child node structure ignoring the documentFragment node itself
        var ulElm = document.querySelector('#for-fragments');
        var docFrag = document.createDocumentFragment();

        ["blue", "green", "red", "blue", "pink"].forEach(function (e) {
            var li = document.createElement("li");
            li.textContent = e;
            docFrag.appendChild(li);
        });

        ulElm.appendChild(docFrag);

        //logs <ul><li>blue</li><li>green</li><li>red</li><li>blue</li><li>pink</li></ul>
        console.log(document.body.innerHTML);

        // using innerHTMl on fragments
        //create a <div> and document fragment
        var divElm = document.createElement('div');
        docFrag = document.createDocumentFragment();

        //append div to document fragment
        docFrag.appendChild(divElm);

        //create a DOM structure from a string
        docFrag.querySelector('div').innerHTML = '<ul><li>foo</li><li>bar</li></ul>';

        //the string becomes a DOM structure I can call methods on like querySelectorAll()
        //Just don't forget the DOM structure is wrapped in a <div>
        console.log(docFrag.querySelectorAll('li').length); //logs 2
        ulElm.appendChild(docFrag);

        // When appending a documentFragment the nodes contained in the Fragment are moved from the Fragment to the structure you are appending too
        // To leave the contents of a fragment in memory, so the nodes remain after appending, simply clone using cloneNode() the documentFragment when appending
        //append cloned document fragment to ul in live DOM
        ulElm.appendChild(docFrag.cloneNode(true));

        //logs <li>blue</li><li>green</li><li>red</li><li>blue</li><li>pink</li>
        console.log(document.querySelector('ul').innerHTML);

        //logs [li,li,li,li,li] 
        console.log(docFrag.childNodes);

    </script>

    <!-- document.styleSheets gives access to a list of all style sheet objects (aka CSSStylesheet) explicitly linked (i.e. <link>) or embedded (i.e. <style>) in an HTML document -->
    <style id="styleElement">
        body {
            background-color: #fff;
            margin: 20px;
        }

        /*index 0*/

        p {
            line-height: 1.4em;
            color: blue;
        }

        /*index 1*/

        strong {
            color: green;
        }
    </style>
    <p id="for-css">Hi <strong>dude!!</strong></p>
    <script>

        console.log(document.styleSheets.length); //logs 2
        console.log(document.styleSheets[0]); // the <link>
        console.log(document.styleSheets[1]); // the <style>

        // In addtion to using styleSheets to access a documents styles sheets its also possible to access a style sheet in an HTML document by first selecting the element in the DOM (<style> or <link>) and using the .sheet property to gain access to the CSSStyleSheet object
        //get CSSStylesheeet object for <link>
        console.log(document.querySelector('#linkElement').sheet); //same as document.styleSheets[0] 

        //get CSSSstylesheet object for <style>
        console.log(document.querySelector('#styleElement').sheet); //same as document.styleSheets[1]

        // var sSheet = document.querySelector('#styleElement');

        // console.log(sSheet.cssRules[0].cssText); //logs "body { background-color: red; margin: 20px; }"
        // console.log(sSheet.cssRules[1].cssText); //logs "p { line-height: 1.4em; color: blue; }"

        var sSheet = document.querySelector('#styleElement').sheet;

        //array like list containing all of the CSSrule objects repreesenting each CSS rule in the style sheet
        console.log(sSheet.cssRules);

        console.log(sSheet.cssRules.length); //logs 2

        //rules are index in a CSSRules list starting at a 0 index
        console.log(sSheet.cssRules[0]); //logs first rule
        console.log(sSheet.cssRules[1]); //logs second rule

        // insertRule() and deleteRule() methods provided the ability to programatically manipulate the CSS rules in a style sheet
        // Deleting or removing a rule is as simple as calling deleteRule() method on a style sheet and passing it the index of the rule in the style sheet to be deleted
        // Its much simpler working with CSS rules in CSS and HTML files before they are served to a client than programaticlly altering them in the client after the fact
        //add a new CSS rule at index 1 in the inline style sheet
        // document.querySelector('#styleElement').sheet.insertRule('p{color:red}', 1);
        document.querySelector('#styleElement').sheet.insertRule('#for-css{color:red}', 1);

        //verify it was added
        console.log(document.querySelector('#styleElement').sheet.cssRules[1].cssText);

        //Delete what we just added
        document.querySelector('#styleElement').sheet.deleteRule(1);

        //verify it was removed
        console.log(document.querySelector('#styleElement').sheet.cssRules[1].cssText);

        // .style property for CSSStyleRule objects that orchestrates the same manipulation of styles in style sheets
        styleSheet = document.querySelector('#styleElement').sheet;

        //Set css rules in stylesheet
        styleSheet.cssRules[0].style.color = 'red';
        styleSheet.cssRules[1].style.color = 'purple';

        //Get css rules
        console.log(styleSheet.cssRules[0].style.color); //logs 'red'
        console.log(styleSheet.cssRules[1].style.color); //logs 'purple'

        // To craft a new style sheet on the fly after an html page is loaded one only has to create a new <style> node, add CSS rules using innerHTML to this node, then append the <style> node to the HTML document.
        var styleElm = document.createElement('style');
        styleElm.innerHTML = 'body{color:red}';

        //notice markup in the document changed to red from our new inline stylesheet
        document.querySelector('head').appendChild(styleElm);

        // To add a CSS file to an HTML document programatically a <link> element node is created with the appropriate attributes and then the <link> element node is appended to the DOM
        //create & add attributes to <link>
        var linkElm = document.createElement('link');
        linkElm.setAttribute('rel', 'stylesheet');
        linkElm.setAttribute('type', 'text/css');
        linkElm.setAttribute('id', 'linkElement');
        linkElm.setAttribute('href', 'http://yui.yahooapis.com/3.3.0/build/cssreset/reset-min.css');

        //Append to the DOM
        document.head.appendChild(linkElm);

        //confrim its addition to the DOM
        console.log(document.querySelector('#linkElement'));

        // Using the .disabled property of a CSSStyleSheet object its possible to enable or disabled a style sheet
        //Get current boolean disabled value
        console.log(document.querySelector('#linkElement').disabled); //log 'false'
        console.log(document.querySelector('#styleElement').disabled); //log 'false'

        //Set disabled value, which of courese disabled all styles for this document
        // document.document.querySelector('#linkElement').disabled = true;
        // document.document.querySelector('#styleElement').disabled = true;
    </script>

    <!-- Trying to include an external JavaScript file and writing page inline JavaScript using the same <script> element will result in the page inline JavaScript being ignored and the exterenal JavaScript file being downloaded and exectued -->
    <!-- If JavaScript code contains the string '</script>' you will have to escape the closing '/' with '<\/script>' so that the parser does not think this is the real closing </script> element -->

    <!-- The default blocking nature of a <script> element can have a significant effect on the perfomrance & percived performance of the visual rendering of a HTML web page -->
    <!-- If you have a couple of script elements at the start of an html page nothing else is happening (e.g. DOM parsing & resource loading) until each one is downloaed and executed sequentially -->

    <!-- stop document parsing, block document parsing, load js, exectue js, then resume document parsing... -->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"></script>

    <!-- stop document parsing, block document parsing, exectue js, then resume document parsing... -->
    <script>console.log('hi');</script>

    <!-- The <script> element has an attribute called defer that will defer the blocking, downloading, and executing of an external JavaScript file until the browser has parsed the closing <html> node -->
    <!-- Using this attribute simply defers what normally occurs when a web browser encoutners a <script> node -->
    <!-- defer, don't block just ignore this until the <html> element node is parsed -->
    <!-- By using defer the assummption is that document.write() is not being used in the JavaScript that will be defered -->
    <script defer src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"></script>

    <!-- defer, don't block just ignore this until the <html> element node is parsed -->
    <script defer src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>

    <!-- defer, don't block just ignore this until the <html> element node is parsed -->
    <script defer src="http://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.0.6/jquery.mousewheel.min.js"></script>

    <script>
        //We know that jQuery is not avaliable because this occurs before the closing <html> element
        console.log(window['jQuery'] === undefined); //logs true

        //Only after everything is loaded can we safley conclude that jQuery was loaded and parsed
        document.body.onload = function () { console.log(jQuery().jquery) }; //logs function
    </script>

    <!-- The <script> element has an attribute called async that will override the sequential blocking nature of <script> elements when the DOM is being constructed by a web browser -->
    <!-- By using this attribute, we are telling the browser not to block the construction (i.e. DOM parsing, including downloading other assets e.g. images, style sheets, etc...) of the html page and forgo the the sequential loading as well -->
    <!-- What happens by using the async attribute is the files are loaded in parallel and parsed in order of download once they are fully downloaded -->
    <!-- A major drawback to using the async attribute is JavaScript files potentially get parsed out of the order they are included in the DOM. This raises a dependency management issue -->
    <!-- Given a <script> elements synchronous nature, placing one in the <head> element of an HTML document presents a timing problem if the JavaScript execution is dependant upon any of the DOM that proceeds the <script> -->
    <!-- In a nut shell, if JavaScript is executed at the begining of a document that manipulates the DOM, that proceeds it, you are going to get a JavaScript error -->

    <!-- Don't block, just start downloading and then parse the file when it's done downloading -->
    <script async src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"></script>

    <!-- Don't block, just start downloading and then parse the file when it's done downloading -->
    <script async src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>

    <!-- Don't block, just start downloading and then parse the file when it's done downloading -->
    <script async src="http://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.0.6/jquery.mousewheel.min.js"></script>


    <script>
        // we have no idea if jQuery has been loaded yet likley not yet...
        console.log(window['jQuery'] === undefined);//logs true

        //Only after everything is loaded can we safley conclude that jQuery was loaded and parsed
        document.body.onload = function () { console.log(jQuery().jquery) };
    </script>

    <!-- A known hack for forcing a web browser into asynchronous JavaScript downloading and parsing without using the async attribure is to programatically create <script> elements that include external JavaScript files and insert them in the DOM -->
    <!-- A major drawback to using dynamic <script> elements is JavaScript files potentially get parsed out of the order they are included in the DOM. This raises a dependency management issue -->

    <!-- Don't block, just start downloading and then parse the file when it's done downloading -->
    <script>
        var underscoreScript = document.createElement("script");
        underscoreScript.src = "http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js";
        document.body.appendChild(underscoreScript);
    </script>

    <!-- Don't block, just start downloading and then parse the file when it's done downloading -->
    <script>
        var jqueryScript = document.createElement("script");
        jqueryScript.src = "http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js";
        document.body.appendChild(jqueryScript);
    </script>

    <!-- Don't block, just start downloading and then parse the file when it's done downloading -->
    <script>
        var mouseWheelScript = document.createElement("script");
        mouseWheelScript.src = "http://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.0.6/jquery.mousewheel.min.js";
        document.body.appendChild(mouseWheelScript);
    </script>

    <script>
        //Only after everything is loaded can we safley conclude that jQuery was loaded and parsed
        document.body.onload = function () { console.log(jQuery().jquery) };
    </script>

    <!-- The <script> element supports a load event handler (ie. onload) that will execute once an external JavaScript file has been loaded and executed -->
    <!-- Don't block, just start downloading and then parse the file when it's done downloading -->
    <script>
        var underscoreScript = document.createElement("script");
        underscoreScript.src = "http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js";
        underscoreScript.onload = function () { console.log('underscsore is loaded and exectuted'); };
        document.body.appendChild(underscoreScript);
    </script>

    <!-- Don't block, just start downloading and then parse the file when it's done downloading -->
    <script async src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js"
        onload="console.log('jQuery is loaded and exectuted');"></script>

    <!-- document.scripts property avaliable from the document object provides a list (i.e. an HTMLCollection) of all of the scripts currently in the DOM-->
    <!-- <script>​
        Array.prototype.slice.call(document.scripts).forEach(function (elm) {
            console.log(elm);
        });//will log each script element in the document
    </script> -->

    <!-- Dom Events -->
    <div id="click-me">click me</div>
    <div id="event-flow">click me to start event flow</div>
    <div id="event-flow02">click me to start event flow without capture events flow</div>
    <div id="mouse-over">mouse over me</div>
    <div id="remove-event">click to say hi</div>
    <div id="event-prop">click me event properties</div>
    <div id="this-value">click me</div>
    <a id="site" href="google.com">no go</a>
    <input id="chk-box" type="checkbox" />
    <textarea id="text-area02"></textarea>
    <div id="stop-propagation">click me</div>
    <div id="imdt-stop">click me</div>
    <div id="custom-event">click me</div>
    <div id="mimic-mouse-events">no need to click, we programatically trigger it</div>​​​​
    <p>Click a table cell</p>

    <table id="event-delegation" border="1">
        <tbody>
            <tr>
                <td>row 1 column 1</td>
                <td>row 1 column 2</td>
            </tr>
            <tr>
                <td>row 2 column 1</td>
                <td>row 2 column 2</td>
            </tr>
            <tr>
                <td>row 3 column 1</td>
                <td>row 3 column 2</td>
            </tr>
            <tr>
                <td>row 4 column 1</td>
                <td>row 4 column 2</td>
            </tr>
            <tr>
                <td>row 5 column 1</td>
                <td>row 5 column 2</td>
            </tr>
            <tr>
                <td>row 6 column 1</td>
                <td>row 6 column 2</td>
            </tr>
        </tbody>
    </table>​​​​​​​​


    <script>
        var elementDiv = document.querySelector('#click-me');

        // property event handler pattern
        elementDiv.onclick = function () { console.log('fire/trigger property event handler') };

        //addEventListener method pattern
        elementDiv.addEventListener('click', function () { console.log('fire/trigger addEventListener') }, false);

        //overrides/replaces the prior value
        elementDiv.onclick = function () { console.log('I win') };

        /*notice that I am passing the addEventListener() a boolean parameter of true so capture events fire, not just bubbling events*/

        //1 capture phase
        window.addEventListener('click', function () { console.log(1); }, true);

        //2 capture phase
        document.addEventListener('click', function () { console.log(2); }, true);

        //3 capture phase
        document.documentElement.addEventListener('click', function () { console.log(3); }, true);

        //4 capture phase
        document.body.addEventListener('click', function () { console.log(4); }, true);

        //5 target phase occurs during capture phase
        document.querySelector('#event-flow').addEventListener('click', function () { console.log(5); }, true);

        //6 target phase occurs during bubbling phase
        document.querySelector('#event-flow').addEventListener('click', function () { console.log(6); }, false);

        //7 bubbling phase
        document.body.addEventListener('click', function () { console.log(7); }, false);

        //8 bubbling phase
        document.documentElement.addEventListener('click', function () { console.log(8); }, false);

        //9 bubbling phase
        document.addEventListener('click', function () { console.log(9); }, false);

        //10 bubbling phase
        window.addEventListener('click', function () { console.log(10) }, false);

        // without capturing phase enabled

        //1 target phase occurs during bubbling phase
        document.querySelector('#event-flow02').addEventListener('click', function () { console.log(11); }, false);

        //2 bubbling phase
        document.body.addEventListener('click', function () { console.log(22); }, false);

        //3 bubbling phase
        document.documentElement.addEventListener('click', function () { console.log(33); }, false);

        //4 bubbling phase
        document.addEventListener('click', function () { console.log(44); }, false);

        //5 bubbling phase
        window.addEventListener('click', function () { console.log(55) }, false);

        //add a mousemove event to the window object, invoking the event during the bubbling phase
        window.addEventListener('mousemove', function () { console.log('moving over window'); }, false);

        //add a mousemove event to the document object, invoking the event during the bubbling phase
        document.addEventListener('mousemove', function () { console.log('moving over document'); }, false);

        //add a mousemove event to a <div> element object, invoking the event during the bubbling phase
        document.querySelector('#mouse-over').addEventListener('mousemove', function () { console.log('moving over div'); }, false);

        // The removeEventListener() method can be used to remove events listeners, if the orginal listener was not added using an anonymous function
        // Anonymous functions added using addEventListener() method simply cannot be removed.

        var sayHi = function () { console.log('hi') };

        //adding event listener using anonymous function
        document.body.addEventListener('click', function () { console.log('dude'); }, false);

        //adding event listener using function reference
        document.querySelector('#remove-event').addEventListener('click', sayHi, false);

        //attempt to remove both event listeners, but only the listener added with a funtions reference is removed
        document.querySelector('#remove-event').removeEventListener('click', sayHi, false);

        //this of course does not work as the function passed to removeEventListener is a new and different function
        document.body.removeEventListener('click', function () { console.log('dude'); }, false);

        //clicking the div will still invoke the click event attached to the body element, this event was not removed

        // event properties
        document.querySelector('#event-prop').addEventListener('click', function (event) {
            Object.keys(event).sort().forEach(function (item) {
                console.log(item + ' = ' + event[item]); //logs event propeties and values
            });
        }, false);

        //assumes 'this' is window
        this.addEventListener('load', function (event) {
            Object.keys(event).sort().forEach(function (item) {
                console.log(item + ' = ' + event[item]); //logs event propeties and values
            });
        }, false);

        // value of 'this' inside of the event listener function passed to the addEventListener() method will be a reference to the node or object the event is attached to
        document.querySelector('#this-value').addEventListener('click', function () {
            // 'this' will be the element or node the event listener is attached too
            console.log(this); //logs '<div>' 
        }, false);

        // Additionally its possible using the event.currentTarget property to get the same reference, to the node or object invoking the event listener, that the this property provides
        document.addEventListener('click', function (event) {
            console.log(event.currentTarget);  //logs '#document'
            //same as...
            console.log(this);
        }, false);

        document.body.addEventListener('click', function (event) {
            console.log(event.currentTarget); //logs '<body>'
            //same as...
            console.log(this);
        }, false);

        document.querySelector('#this-value').addEventListener('click', function (event) {
            console.log(event.currentTarget); //logs '<div>'
            //same as...
            console.log(this);
        }, false);

        // browser events can be prevented by calling the preventDefault() method inside of the event handler function associated with a node or object that invokes a browser default event
        // The preventDefault() methods does not stop events from propagating (i.e. bubbling or capture phases)
        // Providing a return false at the end of the body of the event listener has the same result as call the preventDefault() method
        // The event object passed to event listener functions contains a boolean cancelable property which indicates if the event will respond to preveentDefault() method and canceling default behavior


        document.querySelector('#site').addEventListener('click', function (event) {
            event.preventDefault(); //stop the default event for <a> which would be to load a url
        }, false);

        document.querySelector('#chk-box').addEventListener('click', function (event) {
            event.preventDefault(); //stop default event for checkbox, which would be to toggle checkbox state
        }, false);

        document.querySelector('#text-area02').addEventListener('keypress', function (event) {
            event.preventDefault(); //stop default event for textarea, which would be to add characters typed
            // return false
        }, false);

        /*keep in mind that events still propagate, clicking the link in this html document will stop the default event but not event bubbling*/
        document.body.addEventListener('click', function () {
            console.log('the event flow still flows!');
        }, false);

        // Calling stopProgagation() from within an event handler/listener will stop the capture and bubble event flow phases, but any events directly attached to the node or object will still be invoked
        document.querySelector('#stop-propagation').addEventListener('click', function () {
            console.log('me too, but nothing from the event flow!');
        }, false);

        document.querySelector('#stop-propagation').addEventListener('click', function (event) {
            console.log('invoked all click events attached, but cancel capture and bubble event phases');
            event.stopPropagation();
        }, false);

        document.querySelector('#stop-propagation').addEventListener('click', function () {
            console.log('me too, but nothing from the event flow!');
        }, false);

        /*when the <div> is clicked this event is not invoked because one of the events attached to the <div> stops the capture and bubble flow.*/
        document.body.addEventListener('click', function () {
            console.log('What, denied from being invoked!');
        }, false);

        // Calling the stopImmediatePropagation() from within an event handler/listener will stop the event flow phases (i.e. stopPropagation()), as well as any other like events attached to the event target that are attached after the event listener that invokes the stopImmediatePropagation() method
        // Using the stopImmediatePropagation() does not prevent default events
        // Browser default events still get invoked and only calling preventDefault() will stop these events

        //first event attached
        document.querySelector('#imdt-stop').addEventListener('click', function () {
            console.log('I get invoked because I was attached first');
        }, false);

        //seond event attached
        document.querySelector('#imdt-stop').addEventListener('click', function (event) {
            console.log('I get invoked, but stop any other click events on this target');
            event.stopImmediatePropagation();
        }, false);

        //third event attached, but because stopImmediatePropagation() was called above this event does not get invoked
        document.querySelector('#imdt-stop').addEventListener('click', function () {
            console.log('I get stopped from the previous click event listener');
        }, false);

        //notice that the event flow is also cancelled as if stopPropagation was called too
        document.body.addEventListener('click', function () {
            console.log('What, denied from being invoked!');
        }, false);

        //  Its possible to attach and invoke a custom event, using the addEventListener() method like normal in combiniation with document.createEvent(), initCustomEvent(), and dispatchEvent()
        var divElement = document.querySelector('#custom-event');

        //create the custom event
        var cheer = document.createEvent('CustomEvent'); //the 'CustomEvent' parameter is required

        //create an event listener for the custom event
        divElement.addEventListener('goBigBlue', function (event) {
            console.log(event.detail.goBigBlueIs)
        }, false);

        /*Use the initCustomEvent method to setup the details of the custom event.
        Parameters for initCustomEvent are: (event, bubble?, cancelable?, pass values to event.detail)*/
        cheer.initCustomEvent('goBigBlue', true, false, { goBigBlueIs: 'its gone!' });

        //invoke the custom event using dispatchEvent
        divElement.dispatchEvent(cheer);

        // In the case of simulating a mouse event we create a 'MouseEvent' using document.createEvent()
        // Then, using initMouseEvent() we setup the mouse event that is going to occur
        // Next the mouse event is dispatched on the element that we'd like to simulate an event on
        var divElement = document.querySelector('#mimic-mouse-events');

        //setup click event that will be simulated
        divElement.addEventListener('click', function (event) {
            console.log(Object.keys(event));
        }, false);

        //create simulated mouse event 'click'
        var simulateDivClick = document.createEvent('MouseEvents');

        /*setup simulated mouse 'click'
        initMouseEvent(type,bubbles,cancelable,view,detail,screenx,screeny,clientx,clienty,ctrlKey,altKey,shiftKey,metaKey,button,relatedTarget)*/
        simulateDivClick.initMouseEvent('click', true, true, document.defaultView, 0, 0, 0, 0, 0, false, false, false, 0, null, null);

        //invoke simulated clicked event
        divElement.dispatchEvent(simulateDivClick);


        // Event delegations
        // Event delegation, stated simply, is the programmatic act of leveraging the event flow and a single event listener to deal with multiple event targets
        // A side effect of event delegation is that the event targets don't have to be in the DOM when the event is created in order for the targets to respond to the event
        // This is of course rather handy when dealing with XHR responses that update the DOM
        // Event delegation is ideally leverage when you are dealing with a click, mousedown, mouseup, keydown, keyup, and keypress event type
        
        document.querySelector('#event-delegation').addEventListener('click', function (event) {
            if (event.target.tagName.toLowerCase() === 'td') { //make sure we only run code if a td is the target
                console.log(event.target.textContent); //use event.target to gain access to target of the event which is the td 
            }
        }, false);

    </script>
</body>

</html>